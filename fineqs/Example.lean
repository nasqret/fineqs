/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7e095924-fd86-45da-bb0c-80b7e0ffd57d
-/

/-
We have formalized the results from the provided note "Reducing the number of equations defining a subset of the $n$-space over a finite field".

The main results are:
- `theorem_1`: Any set of functions on a set $X$ of size at most $\frac{q^{n+1}-q}{q-1}$ can be reduced to $n$ functions with the same zero set. (This was provided in the assumptions).
- `prop_1`: Proposition 1, showing that the bound on the size of $X$ in Theorem 1 is sharp.
- `corollary_2`: Corollary 2, applying Theorem 1 to affine space $\mathbb{A}^n(\mathbb{F}_q)$.
- `corollary_3`: Corollary 3, applying Theorem 1 to projective space $\mathbb{P}^n(\mathbb{F}_q)$.
- `remark_example`: The example mentioned in the remark, showing that for the specific case of coordinate functions, $n-1$ equations are not enough.

We also proved the following helper lemmas:
- `matrix_rank_lemma`: Lemma 3 from the text, regarding the factorization of a matrix into a rank $n$ matrix and another matrix.
- `card_projectivization_minus_point`: Calculating the cardinality of projective space minus a point, used in the proof of Corollary 3.

-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 82907431-2f38-44be-b7f3-0e18f63fcd13

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the zero set of a set of functions.
-/
open BigOperators

variable {F : Type*} [Field F] [Fintype F]
variable {X : Type*}

def ZeroSet (S : Set (X → F)) : Set X :=
  {x | ∀ f ∈ S, f x = 0}

/-
Checking definitions of Projectivization and Matrix.vecMul.
-/
open BigOperators

variable {F : Type*} [Field F] [Fintype F]
variable {X : Type*}

#check Projectivization
#check Projectivization.card
#check Matrix.vecMul

/-
Auxiliary lemma for Theorem 1: If X is small enough, and f maps X to F^(n+1), there exists a linear map M to F^n such that M(f(x)) = 0 iff f(x) = 0.
-/
open BigOperators Projectivization

variable {F : Type*} [Field F] [Fintype F]
variable {X : Type*} [Finite X]

lemma theorem_1_aux (n : ℕ) (f : X → (Fin (n + 1) → F))
    (hX : Nat.card X ≤ (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1)) :
    ∃ M : (Fin (n + 1) → F) →ₗ[F] (Fin n → F), {x | M (f x) = 0} = {x | f x = 0} := by
  -- Let $L$ be a line in $V$ that does not intersect the image of $f$ in $P(V)$.
  obtain ⟨L, hL⟩ : ∃ L : Submodule F (Fin (n + 1) → F), L ≠ ⊥ ∧ ∀ x, f x ≠ 0 → ¬ (f x) ∈ L := by
    -- Let $P(V)$ be the projective space of $V$.
    set PV := {L : Submodule F (Fin (n + 1) → F) | L ≠ ⊥ ∧ Module.finrank F L = 1} with hPV_def;
    -- Since $|X| \leq |P(V)| - 1$, there exists a line $L \in PV$ that is not in the image of $f$.
    have hPV_card : Set.ncard PV = (Fintype.card F ^ (n + 1) - 1) / (Fintype.card F - 1) := by
      have hPV_card : Set.ncard PV = (Fintype.card (Fin (n + 1) → F) - 1) / (Fintype.card F - 1) := by
        have hPV_equiv : PV = Set.image (fun v : { v : Fin (n + 1) → F // v ≠ 0 } => Submodule.span F {v.val}) (Set.univ : Set { v : Fin (n + 1) → F // v ≠ 0 }) := by
          ext L; aesop;
          · obtain ⟨ a, ha ⟩ := ( finrank_eq_one_iff'.mp right ) ; use a; aesop;
            refine' le_antisymm _ _;
            · exact Submodule.span_le.mpr ( Set.singleton_subset_iff.mpr property );
            · exact fun x hx => by obtain ⟨ c, rfl ⟩ := right_1 x hx; exact Submodule.smul_mem _ _ ( Submodule.subset_span ( Set.mem_singleton _ ) ) ;
          · rw [ finrank_span_singleton ] ; aesop
        -- Since each line in $PV$ corresponds to $(Fintype.card F - 1)$ non-zero vectors, we can count the number of lines by dividing the number of non-zero vectors by $(Fintype.card F - 1)$.
        have hPV_card : Set.ncard PV = (Set.ncard {v : Fin (n + 1) → F | v ≠ 0}) / (Fintype.card F - 1) := by
          have hPV_card : ∀ L ∈ PV, Set.ncard {v : Fin (n + 1) → F | v ≠ 0 ∧ Submodule.span F {v} = L} = Fintype.card F - 1 := by
            bound;
            -- Since $L$ is a line, there exists a non-zero vector $v$ such that $L = \langle v \rangle$.
            obtain ⟨v, hv⟩ : ∃ v : Fin (n + 1) → F, v ≠ 0 ∧ L = Submodule.span F {v} := by
              replace hPV_equiv := Set.ext_iff.mp hPV_equiv L; aesop;
            -- Since $L = \langle v \rangle$, the set of non-zero vectors in $L$ is exactly $\{cv \mid c \in F, c \neq 0\}$.
            have h_nonzero_vectors : {v : Fin (n + 1) → F | v ≠ 0 ∧ Submodule.span F {v} = L} = Finset.image (fun c : F => c • v) (Finset.univ.erase 0) := by
              ext; simp [hv];
              constructor <;> intro h;
              · have := Submodule.mem_span_singleton.mp ( h.2 ▸ Submodule.mem_span_singleton_self _ );
                aesop;
              · rcases h with ⟨ x, hx, rfl ⟩ ; simp_all +decide [ Submodule.span_singleton_eq_bot ] ;
                rw [ Submodule.span_singleton_eq_span_singleton ];
                exact ⟨ Units.mk0 x⁻¹ ( inv_ne_zero hx ), by simp +decide [ hx ] ⟩;
            rw [ h_nonzero_vectors, Set.ncard_coe_finset, Finset.card_image_of_injective ] <;> simp +decide [ Function.Injective, hv.1 ];
            exact fun x y hxy => smul_left_injective _ hv.1 hxy;
          have hPV_card : Set.ncard {v : Fin (n + 1) → F | v ≠ 0} = ∑ L ∈ Set.Finite.toFinset (show Set.Finite PV from Set.toFinite PV), Set.ncard {v : Fin (n + 1) → F | v ≠ 0 ∧ Submodule.span F {v} = L} := by
                                                                                                simp +decide only [Set.ncard_eq_toFinset_card'];
                                                                                                rw [ ← Finset.card_biUnion ];
                                                                                                · congr with v ; simp +decide [ hPV_equiv ];
                                                                                                  exact fun hv => ⟨ v, hv, rfl ⟩;
                                                                                                · exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun v hvx hvy => hxy <| by aesop;
          rw [ hPV_card, Finset.sum_congr rfl fun L hL => ‹∀ L ∈ PV, Set.ncard { v : Fin ( n + 1 ) → F | v ≠ 0 ∧ Submodule.span F { v } = L } = Fintype.card F - 1› L <| by simpa using hL ] ; simp +decide [ Set.ncard_eq_toFinset_card' ];
          rw [ Nat.mul_div_cancel _ ( Nat.sub_pos_of_lt ( Fintype.one_lt_card ) ) ] ; rfl;
        simp +decide [ hPV_card, Set.ncard_eq_toFinset_card' ];
        simp +decide [ Finset.filter_ne' ];
      aesop;
    -- Since $|X| \leq |P(V)| - 1$, there exists a line $L \in PV$ that is not in the image of $f$. We'll use the fact that $|P(V)| = \frac{q^{n+1} - 1}{q - 1}$.
    have hPV_card_ge : (Set.ncard PV) > (Set.ncard {L : Submodule F (Fin (n + 1) → F) | ∃ x, f x ≠ 0 ∧ L = Submodule.span F {f x}}) := by
      have hPV_card_ge : (Set.ncard {L : Submodule F (Fin (n + 1) → F) | ∃ x, f x ≠ 0 ∧ L = Submodule.span F {f x}}) ≤ (Nat.card X) := by
        have hPV_card_ge : (Set.ncard {L : Submodule F (Fin (n + 1) → F) | ∃ x, f x ≠ 0 ∧ L = Submodule.span F {f x}}) ≤ (Set.ncard (Set.image (fun x => Submodule.span F {f x}) {x : X | f x ≠ 0})) := by
          apply Set.ncard_le_ncard;
          · exact fun L hL => by obtain ⟨ x, hx, rfl ⟩ := hL; exact ⟨ x, hx, rfl ⟩ ;
          · exact Set.toFinite _;
        refine' le_trans hPV_card_ge _;
        refine' le_trans ( Set.ncard_image_le ) _;
        exact Set.ncard_le_ncard ( Set.subset_univ _ ) |> le_trans <| by simp +decide [ Set.ncard_univ ] ;
      refine' lt_of_le_of_lt hPV_card_ge ( hX.trans_lt _ );
      rw [ hPV_card, Nat.div_lt_iff_lt_mul <| Nat.sub_pos_of_lt <| Fintype.one_lt_card ];
      rw [ Nat.div_mul_cancel ];
      · exact tsub_lt_tsub_left_of_le ( Nat.le_self_pow ( by norm_num ) _ ) ( Fintype.one_lt_card );
      · exact?;
    contrapose! hPV_card_ge;
    apply Set.ncard_le_ncard;
    · intro L hL;
      obtain ⟨ x, hx ⟩ := hPV_card_ge L hL.1;
      have h_span : Submodule.span F {f x} = L := by
        refine' Submodule.eq_of_le_of_finrank_eq _ _;
        · exact Submodule.span_le.mpr ( Set.singleton_subset_iff.mpr hx.2 );
        · rw [ hL.2, finrank_span_singleton ] ; aesop;
      exact ⟨ x, hx.1, h_span.symm ⟩;
    · exact Set.Finite.subset ( Set.toFinite ( Set.range fun x : X => Submodule.span F { f x } ) ) fun L hL => by aesop;
  -- By Lemma 25, there exists a linear map $M : V \to F^n$ such that $\ker M = L$.
  obtain ⟨M, hM⟩ : ∃ M : (Fin (n + 1) → F) →ₗ[F] Fin n → F, LinearMap.ker M = L := by
    have h_quot : ∃ M : (Fin (n + 1) → F) ⧸ L →ₗ[F] Fin n → F, Function.Injective M := by
      have h_quot : Module.finrank F ((Fin (n + 1) → F) ⧸ L) ≤ n := by
        have := Submodule.finrank_quotient_add_finrank L; aesop; (
        linarith [ show Module.finrank F L > 0 from Nat.pos_of_ne_zero ( by aesop ) ]);
      have h_quot : ∃ M : (Fin (n + 1) → F) ⧸ L →ₗ[F] Fin (Module.finrank F ((Fin (n + 1) → F) ⧸ L)) → F, Function.Injective M := by
        have := ( Module.finBasis F ( ( Fin ( n + 1 ) → F ) ⧸ L ) );
        exact ⟨ this.equivFun, this.equivFun.injective ⟩;
      obtain ⟨ M, hM ⟩ := h_quot; use M.comp ( LinearMap.id ) |> LinearMap.comp ( LinearMap.pi fun i => if h : i.val < Module.finrank F ( ( Fin ( n + 1 ) → F ) ⧸ L ) then LinearMap.proj ⟨ i.val, h ⟩ else 0 ) ; aesop;
      intro x y hxy; have := congr_fun hxy; aesop;
      exact hM <| funext fun i => by specialize this ⟨ i, by linarith [ Fin.is_lt i ] ⟩ ; aesop;
    obtain ⟨ M, hM ⟩ := h_quot; use M.comp ( Submodule.mkQ L ) ; simp_all +decide [ SetLike.ext_iff, LinearMap.ext_iff ] ;
  use M; ext x; by_cases hx : f x = 0 <;> simp_all +decide [ Set.ext_iff ] ;
  simp_all +decide [ SetLike.ext_iff ]

/-
Base case of Theorem 1: If a set of functions S has size n+1, and X is small enough, we can find a set T of size at most n in the span of S with the same zero set.
-/
lemma theorem_1_base_case (n : ℕ) (S : Set (X → F)) (hS : S.Finite) (h_card : S.ncard = n + 1)
    (hX : Nat.card X ≤ (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1)) :
    ∃ T : Set (X → F), T ⊆ Submodule.span F S ∧ T.Finite ∧ T.ncard ≤ n ∧ ZeroSet T = ZeroSet S := by
  by_contra h_contra;
  norm_num +zetaDelta at *;
  -- Since S has cardinality n+1, we can enumerate S as {f_0, ..., f_n}.
  obtain ⟨f, hf_enum⟩ : ∃ f : Fin (n + 1) → (X → F), S = Set.range f := by
    have := hS.exists_finset_coe; aesop;
    have h_enum : ∃ f : Fin (n + 1) → X → F, Function.Injective f ∧ ∀ i, f i ∈ w := by
      have := Finset.equivFinOfCardEq h_card;
      exact ⟨ fun i => this.symm i |>.1, fun i j hij => by simpa [ Fin.ext_iff ] using this.symm.injective ( Subtype.ext hij ), fun i => this.symm i |>.2 ⟩;
    obtain ⟨ f, hf_inj, hf_mem ⟩ := h_enum; use f; ext x; aesop;
    have := Finset.eq_of_subset_of_card_le ( show Finset.image f Finset.univ ⊆ w from Finset.image_subset_iff.2 fun i _ => hf_mem i ) ( by rw [ Finset.card_image_of_injective _ hf_inj, Finset.card_fin, h_card ] ) ; aesop;
  -- Apply theorem_1_aux to f.
  obtain ⟨M, hM⟩ : ∃ M : (Fin (n + 1) → F) →ₗ[F] (Fin n → F), {x | M (fun i => (f i) x) = 0} = {x | ∀ i, (f i) x = 0} := by
    convert theorem_1_aux n ( fun x i => f i x ) _;
    · exact funext_iff.symm;
    · exact hX;
  -- Let v_j = M(basis_j) for j in Fin (n+1).
  obtain ⟨v, hv⟩ : ∃ v : Fin (n + 1) → Fin n → F, ∀ y : Fin (n + 1) → F, M y = ∑ j, y j • v j := by
    use fun j => M (Pi.single j 1);
    intro y; erw [ M.pi_apply_eq_sum_univ ] ; simp +decide [ Finset.sum_apply, Pi.single_apply ] ;
    exact Finset.sum_congr rfl fun i _ => by congr; ext j; aesop;
  -- Let g_k = sum_j (v_j)_k (e j).val.
  set g : Fin n → (X → F) := fun k => ∑ j, (v j k) • f j;
  refine' h_contra ( Set.range g ) _ _ _ _;
  · exact Set.range_subset_iff.mpr fun k => Submodule.sum_mem _ fun j _ => Submodule.smul_mem _ _ ( Submodule.subset_span ( hf_enum.symm ▸ Set.mem_range_self _ ) );
  · exact Set.toFinite _;
  · exact le_trans ( Set.ncard_le_ncard ( show Set.range g ⊆ Set.range g from Set.Subset.refl _ ) ) ( by rw [ Set.ncard_eq_toFinset_card _ ] ; simpa using Finset.card_image_le.trans ( by simp +decide ) );
  · simp_all +decide [ Set.ext_iff, ZeroSet ];
    simp +zetaDelta at *;
    simp_all +decide [ funext_iff, Finset.sum_apply, mul_comm ]

/-
Base case of Theorem 1: If a set of functions S has size n+1, and X is small enough, we can find a set T of size at most n in the span of S with the same zero set.
-/
lemma theorem_1_base_case_v2 (n : ℕ) (S : Set (X → F)) (hS : S.Finite) (h_card : S.ncard = n + 1)
    (hX : Nat.card X ≤ (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1)) :
    ∃ T : Set (X → F), T ⊆ Submodule.span F S ∧ T.Finite ∧ T.ncard ≤ n ∧ ZeroSet T = ZeroSet S := by
  convert theorem_1_base_case n S hS h_card hX

/-
Theorem 1: If X is small enough, any finite set of functions S with |S| > n can be reduced to a set T of size at most n with the same zero set.
-/
theorem theorem_1 [Finite X] (n : ℕ) (S : Set (X → F)) (hS : S.Finite) (hn : S.ncard > n)
    (hX : Nat.card X ≤ (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1)) :
    ∃ T : Set (X → F), T ⊆ Submodule.span F S ∧ T.Finite ∧ T.ncard ≤ n ∧ ZeroSet T = ZeroSet S := by
  -- By induction on the cardinality of S, we can reduce the problem to the base case.
  set k := S.ncard with hk_def
  have h_ind : ∀ k ≥ n + 1, ∀ (S : Set (X → F)), S.Finite → S.ncard = k → ∃ T : Set (X → F), T ⊆ Submodule.span F S ∧ T.Finite ∧ T.ncard ≤ n ∧ ZeroSet T = ZeroSet S := by
    intro k hk S hS hS_card
    induction' k, Nat.succ_le.mpr hk using Nat.le_induction with k hk ih generalizing S;
    · exact?;
    · -- Choose an element f in S. Let S' = S \ {f}.
      obtain ⟨f, hf⟩ : ∃ f ∈ S, True := by
        exact Exists.elim ( Set.nonempty_of_ncard_ne_zero ( by rw [ hS_card ] ; positivity ) ) fun x hx => ⟨ x, hx, trivial ⟩
      set S' := S \ {f} with hS'_def
      have hS'_card : S'.ncard = k := by
        rw [ Set.ncard_diff _ _ ] <;> aesop
      have hS'_finite : S'.Finite := by
        exact hS.subset fun x hx => hx.1
      obtain ⟨T', hT'_sub, hT'_finite, hT'_card, hT'_zero⟩ : ∃ T' : Set (X → F), T' ⊆ Submodule.span F S' ∧ T'.Finite ∧ T'.ncard ≤ n ∧ ZeroSet T' = ZeroSet S' := by
        exact ih ( by linarith ) S' hS'_finite hS'_card
      set U := T' ∪ {f} with hU_def
      have hU_sub : U ⊆ Submodule.span F S := by
        simp_all +decide [ Set.insert_subset_iff ];
        exact ⟨ Submodule.subset_span hf, hT'_sub.trans ( Submodule.span_mono <| Set.diff_subset ) ⟩
      have hU_card : U.ncard ≤ n + 1 := by
        exact le_trans ( Set.ncard_union_le _ _ ) ( add_le_add_right hT'_card _ ) |> le_trans <| by simp +decide ;
      have hU_zero : ZeroSet U = ZeroSet S := by
        ext x; simp [hU_def, hT'_zero];
        simp_all +decide [ Set.ext_iff, ZeroSet ];
        exact ⟨ fun h g hg => if hg' : g = f then hg'.symm ▸ h.1 else h.2 g hg hg', fun h => ⟨ h f hf, fun g hg hg' => h g hg ⟩ ⟩
      by_cases hU_card_le_n : U.ncard ≤ n;
      · exact ⟨ U, hU_sub, Set.Finite.union hT'_finite ( Set.finite_singleton f ), hU_card_le_n, hU_zero ⟩;
      · -- Since $|U| = n + 1$, we can apply the base case to $U$.
        obtain ⟨T'', hT''_sub, hT''_finite, hT''_card, hT''_zero⟩ : ∃ T'' : Set (X → F), T'' ⊆ Submodule.span F U ∧ T''.Finite ∧ T''.ncard ≤ n ∧ ZeroSet T'' = ZeroSet U := by
          apply theorem_1_base_case_v2 n U (by
          exact hT'_finite.union ( Set.finite_singleton f )) (by
          linarith) (by
          exact hX);
        refine' ⟨ T'', _, hT''_finite, hT''_card, hT''_zero.trans hU_zero ⟩;
        exact hT''_sub.trans ( Submodule.span_mono hU_sub ) |> Set.Subset.trans <| by simp +decide [ Submodule.span_le ] ;
  exact h_ind k hn S hS rfl


#check Projectivization.rep
#check Matrix.rank

/-
For any matrix $A \in M_{n, m}(\K)$ where $n\le m$ there exist a matrix $M \in M_{n, m}(\K)$ having rank equal to $n$, and a matrix $B \in M_{n, n}(\K)$ such that $A=BM$.
-/
lemma matrix_rank_lemma (n m : ℕ) (h : n ≤ m) (A : Matrix (Fin n) (Fin m) F) :
    ∃ (B : Matrix (Fin n) (Fin n) F) (M : Matrix (Fin n) (Fin m) F),
      M.rank = n ∧ A = B * M := by
        -- Let $r$ be the rank of $A$.
        set r := Matrix.rank A;
        -- Let $v_1, \dots, v_r$ be a basis for the row space of $A$.
        obtain ⟨v, hv⟩ : ∃ v : Fin r → Fin m → F, LinearIndependent F v ∧ ∀ i, v i ∈ Submodule.span F (Set.range (Matrix.row A)) := by
          have h_subspace : ∃ v : Fin r → (Fin m → F), LinearIndependent F v ∧ ∀ i, v i ∈ Submodule.span F (Set.range (Matrix.row A)) := by
            have h_subspace_dim : Module.finrank F (Submodule.span F (Set.range (Matrix.row A))) = r := by
              aesop;
              exact?
            have := h_subspace_dim ▸ ( Module.finBasis F ( Submodule.span F ( Set.range A.row ) ) );
            refine' ⟨ _, _, _ ⟩;
            exact fun i => this i;
            · exact this.linearIndependent.map' ( Submodule.subtype _ ) ( by simp +decide );
            · exact fun i => Submodule.coe_mem _;
          exact h_subspace;
        -- Since $r \le n \le m$, we can extend this linearly independent set to a linearly independent set $v_1, \dots, v_n$ in $F^m$.
        obtain ⟨w, hw⟩ : ∃ w : Fin (n - r) → Fin m → F, LinearIndependent F (Sum.elim v w) := by
          have h_ext : ∃ w : Fin (n - r) → Fin m → F, LinearIndependent F (Sum.elim v w) := by
            have h_subspace : ∃ W : Submodule F (Fin m → F), W ⊓ Submodule.span F (Set.range v) = ⊥ ∧ Module.finrank F W = n - r := by
              have h_subspace : ∃ W : Submodule F (Fin m → F), W ⊓ Submodule.span F (Set.range v) = ⊥ ∧ Module.finrank F W = m - r := by
                have := Submodule.exists_isCompl ( Submodule.span F ( Set.range v ) );
                obtain ⟨ W, hW ⟩ := this;
                refine' ⟨ W, _, _ ⟩;
                · exact hW.symm.inf_eq_bot;
                · have := Submodule.finrank_sup_add_finrank_inf_eq ( Submodule.span F ( Set.range v ) ) W;
                  rw [ hW.sup_eq_top, hW.inf_eq_bot ] at this ; aesop;
                  rw [ finrank_span_eq_card ] <;> aesop;
              obtain ⟨ W, hW₁, hW₂ ⟩ := h_subspace;
              have h_subspace : ∃ W' : Submodule F W, Module.finrank F W' = n - r := by
                have h_subspace : ∃ W' : Submodule F W, Module.finrank F W' = n - r := by
                  have h_dim : n - r ≤ Module.finrank F W := by
                    exact hW₂.symm ▸ Nat.sub_le_sub_right h _
                  have := ( Module.finBasis F W );
                  refine' ⟨ Submodule.span F ( Set.range ( this ∘ Fin.castLE h_dim ) ), _ ⟩;
                  rw [ finrank_span_eq_card ] <;> aesop;
                  exact this.linearIndependent.comp _ ( Fin.castLE_injective _ );
                exact h_subspace;
              obtain ⟨ W', hW' ⟩ := h_subspace;
              refine' ⟨ Submodule.map ( Submodule.subtype W ) W', _, _ ⟩;
              · simp_all +decide [ Submodule.eq_bot_iff ];
              · convert hW' using 1;
                rw [ ← Submodule.finrank_map_subtype_eq ]
            obtain ⟨ W, hW₁, hW₂ ⟩ := h_subspace;
            obtain ⟨w, hw⟩ : ∃ w : Fin (n - r) → W, LinearIndependent F w := by
              have := hW₂ ▸ Module.finBasis F W;
              exact ⟨ _, this.linearIndependent ⟩;
            refine' ⟨ fun i => w i, _ ⟩;
            rw [ linearIndependent_sum ];
            simp_all +decide [ Submodule.disjoint_def ];
            refine' ⟨ _, _ ⟩;
            · exact hw.map' ( Submodule.subtype W ) ( by aesop );
            · intro x hx₁ hx₂;
              rw [ Submodule.eq_bot_iff ] at hW₁;
              exact hW₁ x ⟨ by exact Submodule.span_le.mpr ( Set.range_subset_iff.mpr fun i => w i |>.2 ) hx₂, hx₁ ⟩;
          exact h_ext;
        -- Let $M$ be the matrix whose rows are $v_1, \dots, v_n$.
        set M : Matrix (Fin n) (Fin m) F := Matrix.of (fun i j => if h : i.val < r then v ⟨i.val, h⟩ j else w ⟨i.val - r, by
          grind⟩ j)
        generalize_proofs at *;
        -- Since $v_1, \dots, v_n$ are linearly independent, the rank of $M$ is $n$.
        have hM_rank : Matrix.rank M = n := by
          refine' le_antisymm _ _;
          · exact le_trans ( Submodule.finrank_le _ ) ( by simp +decide );
          · have hM_rank : LinearMap.range (Matrix.mulVecLin M.transpose) ≥ Submodule.span F (Set.range (Sum.elim v w)) := by
              rw [ ge_iff_le, Submodule.span_le ];
              norm_num +zetaDelta at *;
              constructor <;> rintro _ ⟨ i, rfl ⟩ <;> [ exact ⟨ Pi.single ⟨ i, by linarith [ Fin.is_lt i, show r ≤ n from le_trans ( Submodule.finrank_le _ ) ( by simp +decide ) ] ⟩ 1, by ext j; aesop ⟩ ; exact ⟨ Pi.single ⟨ i + r, by linarith [ Fin.is_lt i, show r ≤ n from le_trans ( Submodule.finrank_le _ ) ( by simp +decide ), Nat.sub_add_cancel ( show r ≤ n from le_trans ( Submodule.finrank_le _ ) ( by simp +decide ) ) ] ⟩ 1, by ext j; aesop ⟩ ];
            have hM_rank : Module.finrank F (Submodule.span F (Set.range (Sum.elim v w))) = n := by
              rw [ finrank_span_eq_card ] <;> aesop;
              rw [ Nat.add_sub_of_le ( show A.rank ≤ n from le_trans ( Matrix.rank_le_card_height A ) ( by simpa ) ) ];
            have hM_rank : Module.finrank F (LinearMap.range (Matrix.mulVecLin M.transpose)) ≥ Module.finrank F (Submodule.span F (Set.range (Sum.elim v w))) := by
              exact Submodule.finrank_mono ‹_›;
            rw [ ← Matrix.rank_transpose ];
            exact?;
        -- Since the rows of $A$ are in the span of $v_1, \dots, v_r$, they are in the span of the rows of $M$.
        have hA_span : ∀ i, A.row i ∈ Submodule.span F (Set.range M.row) := by
          intro i
          have h_row_i : A.row i ∈ Submodule.span F (Set.range (fun i : Fin r => v i)) := by
            have h_row_i : Submodule.span F (Set.range (Matrix.row A)) = Submodule.span F (Set.range v) := by
              have h_subspace : Module.finrank F (Submodule.span F (Set.range (Matrix.row A))) = r := by
                convert Matrix.rank_transpose A using 1;
                congr;
                · ext; simp +decide [ Matrix.mulVec, dotProduct, Submodule.mem_span_range_iff_exists_fun ] ;
                  bound;
                  · exact ⟨ w_1, by ext j; simp +decide [ Matrix.vecMul, dotProduct, Finset.mul_sum _ _ _ ] ⟩;
                  · exact ⟨ w_1, by ext j; simp +decide [ Matrix.vecMul, dotProduct, mul_comm ] ⟩;
                · ext; simp [Matrix.mulVecLin];
                  simp +decide [ Submodule.mem_span_range_iff_exists_fun, Matrix.vecMul ];
                  simp +decide [ funext_iff, Matrix.vecMul, dotProduct ];
                · ext; simp [Matrix.mulVecLin];
                  simp +decide [ Submodule.mem_span_range_iff_exists_fun, Matrix.vecMul ];
                  simp +decide [ funext_iff, Matrix.vecMul, dotProduct ];
              have h_subspace : Submodule.span F (Set.range v) = Submodule.span F (Set.range (Matrix.row A)) := by
                refine' Submodule.eq_of_le_of_finrank_eq _ _;
                · exact Submodule.span_le.mpr ( Set.range_subset_iff.mpr hv.2 );
                · rw [ h_subspace, finrank_span_eq_card ] <;> aesop;
              rw [h_subspace];
            exact h_row_i ▸ Submodule.subset_span ( Set.mem_range_self i );
          refine' Submodule.span_le.mpr _ h_row_i;
          rintro _ ⟨ i, rfl ⟩;
          exact Submodule.subset_span ⟨ ⟨ i, by linarith [ Fin.is_lt i, Nat.sub_add_cancel ( show r ≤ n from le_trans ( Matrix.rank_le_card_height A ) ( by simpa ) ) ] ⟩, by aesop ⟩;
        -- Therefore, each row of $A$ can be written as a linear combination of the rows of $M$.
        have hA_comb : ∀ i, ∃ b : Fin n → F, A.row i = ∑ j, b j • M.row j := by
          intro i
          obtain ⟨b, hb⟩ : ∃ b : Fin n → F, A.row i = ∑ j, b j • M.row j := by
            have h_comb : A.row i ∈ Submodule.span F (Set.range M.row) := hA_span i
            rw [ Finsupp.mem_span_range_iff_exists_finsupp ] at h_comb;
            obtain ⟨ c, hc ⟩ := h_comb;
            exact ⟨ c, by simpa [ Finsupp.sum_fintype ] using hc.symm ⟩;
          use b;
        choose b hb using hA_comb;
        refine' ⟨ Matrix.of ( fun i j => b i j ), M, hM_rank, _ ⟩;
        ext i j; specialize hb i; replace hb := congr_fun hb j; simp_all +decide [ Matrix.mul_apply, Finset.mul_sum _ _ _ ] ;

#check Projectivization.rep_nonzero
#check Projectivization.mk_rep

/-
For every field $\F$ and every positive integer $n$ there are a set $X_{n}$ of cardinality $\frac{q^{n+1}-q}{q-1}+1$, and maps $f_{1}, \ldots, f_{n+1} \in \mathrm{Map}(X_{n},\F)$ such that $\mathrm{Z}(f_{1}, \ldots, f_{n+1})=\emptyset$ but $\mathrm{Z}(g_{1}, \ldots, g_{n})\ne \emptyset$ for any $g_{1}, \ldots, g_{n} \in \mathrm{Span}(f_{1}, \ldots, f_{n+1})$.
-/
theorem prop_1 (n : ℕ) (hn : n > 0) :
    ∃ (X : Set (Fin (n + 1) → F)) (f : Fin (n + 1) → X → F),
      X.ncard = (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1) + 1 ∧
      (∀ x : X, ∃ i, f i x ≠ 0) ∧
      (∀ (g : Fin n → X → F), (∀ j, g j ∈ Submodule.span F (Set.range f)) →
        ∃ x : X, ∀ j, g j x = 0) := by
          -- Let $X$ be the set of homogeneous coordinates of points in $\mathbb{P}^n(\F)$.
          obtain ⟨X, hX⟩ : ∃ X : Set (Fin (n + 1) → F), X.ncard = (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1) + 1 ∧ (∀ x : (Fin (n + 1) → F), x ∈ X → x ≠ 0) ∧ (∀ x : (Fin (n + 1) → F), x ≠ 0 → ∃ y ∈ X, ∃ c : F, c ≠ 0 ∧ x = c • y) := by
            -- Let $X$ be the set of homogeneous coordinates of points in $\mathbb{P}^n(\F)$, excluding the zero vector.
            obtain ⟨X, hX⟩ : ∃ X : Set (Fin (n + 1) → F), X.ncard = (Fintype.card F ^ (n + 1) - 1) / (Fintype.card F - 1) ∧ (∀ x : (Fin (n + 1) → F), x ∈ X → x ≠ 0) ∧ (∀ x : (Fin (n + 1) → F), x ≠ 0 → ∃ y ∈ X, ∃ c : F, c ≠ 0 ∧ x = c • y) := by
              -- Let $X$ be the set of non-zero vectors in $\mathbb{F}^{n+1}$ modulo scalar multiplication.
              set X := Finset.image (fun x : Fin (n + 1) → F => {y : Fin (n + 1) → F | ∃ c : F, c ≠ 0 ∧ y = c • x}) (Finset.univ.filter (fun x : Fin (n + 1) → F => x ≠ 0)) with hX_def;
              have hX_card : X.card = (Fintype.card F ^ (n + 1) - 1) / (Fintype.card F - 1) := by
                have hX_card : X.card * (Fintype.card F - 1) = (Finset.univ.filter (fun x : Fin (n + 1) → F => x ≠ 0)).card := by
                  have hX_card : ∀ y ∈ X, (Finset.filter (fun x => {z : Fin (n + 1) → F | ∃ c : F, ¬c = 0 ∧ z = c • x} = y) (Finset.univ.filter (fun x : Fin (n + 1) → F => x ≠ 0))).card = (Fintype.card F - 1) := by
                    intro y hy
                    obtain ⟨x, hx⟩ : ∃ x : Fin (n + 1) → F, x ≠ 0 ∧ {z : Fin (n + 1) → F | ∃ c : F, ¬c = 0 ∧ z = c • x} = y := by
                      aesop;
                    have hX_card : Finset.filter (fun z => {w : Fin (n + 1) → F | ∃ c : F, ¬c = 0 ∧ w = c • z} = y) (Finset.univ.filter (fun z : Fin (n + 1) → F => z ≠ 0)) = Finset.image (fun c : F => c • x) (Finset.univ.erase 0) := by
                      ext z; simp [hx];
                      constructor <;> intro hz <;> simp_all +decide [ Set.ext_iff ];
                      · obtain ⟨ c, hc, rfl ⟩ := hx.2 z |>.2 ( hz.2 z |>.1 ⟨ 1, one_ne_zero, by simp +decide ⟩ );
                        exact ⟨ c, hc, rfl ⟩;
                      · rcases hz with ⟨ a, ha, rfl ⟩ ; simp_all +decide [ smul_smul ] ;
                        exact fun y => ⟨ fun ⟨ c, hc, hy ⟩ => hx.2 y |>.1 ⟨ c * a, mul_ne_zero hc ha, hy ⟩, fun hy => by rcases hx.2 y |>.2 hy with ⟨ c, hc, rfl ⟩ ; exact ⟨ c / a, div_ne_zero hc ha, by simp +decide [ div_mul_cancel₀ _ ha ] ⟩ ⟩;
                    rw [ hX_card, Finset.card_image_of_injective ] <;> simp +decide [ Function.Injective, hx.1 ];
                    exact fun a₁ a₂ h => smul_left_injective _ hx.1 h;
                  have hX_card : Finset.card (Finset.univ.filter (fun x : Fin (n + 1) → F => x ≠ 0)) = Finset.sum X (fun y => (Finset.filter (fun x => {z : Fin (n + 1) → F | ∃ c : F, ¬c = 0 ∧ z = c • x} = y) (Finset.univ.filter (fun x : Fin (n + 1) → F => x ≠ 0))).card) := by
                    rw [ Finset.card_eq_sum_ones, Finset.sum_image' ] ; aesop;
                  rw [ hX_card, Finset.sum_congr rfl ‹_›, Finset.sum_const, smul_eq_mul, mul_comm ];
                simp_all +decide [ Finset.filter_ne' ];
                rw [ ← hX_card, Nat.mul_div_cancel _ ( Nat.sub_pos_of_lt ( Fintype.one_lt_card ) ) ];
              -- Let's choose any representative from each equivalence class in X.
              obtain ⟨X_rep, hX_rep⟩ : ∃ X_rep : Finset (Fin (n + 1) → F), X_rep.card = X.card ∧ (∀ x ∈ X_rep, x ≠ 0) ∧ (∀ x : Fin (n + 1) → F, x ≠ 0 → ∃ y ∈ X_rep, ∃ c : F, c ≠ 0 ∧ x = c • y) := by
                have hX_rep : ∀ y ∈ X, ∃ x : Fin (n + 1) → F, x ≠ 0 ∧ y = {z : Fin (n + 1) → F | ∃ c : F, c ≠ 0 ∧ z = c • x} := by
                  aesop;
                choose! f hf using hX_rep;
                refine' ⟨ Finset.image f X, _, _, _ ⟩;
                · rw [ Finset.card_image_of_injOn ];
                  intro y hy z hz h_eq;
                  rw [ hf y hy |>.2, hf z hz |>.2, h_eq ];
                · grind;
                · intro x hx;
                  simp +zetaDelta at *;
                  exact ⟨ x, hx, by have := hf x hx; exact this.2.subset ⟨ 1, one_ne_zero, by simp +decide ⟩ |> fun ⟨ c, hc, hc' ⟩ => ⟨ c, hc, hc' ⟩ ⟩;
              exact ⟨ X_rep, by rw [ Set.ncard_coe_finset, hX_rep.1, hX_card ], hX_rep.2.1, hX_rep.2.2 ⟩;
            refine' ⟨ X, _, hX.2.1, hX.2.2 ⟩;
            rw [ hX.1, show Fintype.card F ^ ( n + 1 ) - 1 = ( Fintype.card F ^ ( n + 1 ) - Fintype.card F ) + ( Fintype.card F - 1 ) from ?_, Nat.add_div ] <;> norm_num;
            · rw [ Nat.div_self ( Nat.sub_pos_of_lt ( Fintype.one_lt_card ) ) ];
              rw [ if_neg ];
              refine' not_le_of_gt ( lt_of_le_of_lt ( Nat.succ_le_of_lt ( Nat.mod_lt _ ( Nat.sub_pos_of_lt ( Fintype.one_lt_card ) ) ) ) _ );
              exact Nat.pred_lt ( ne_bot_of_gt ( Fintype.card_pos ) );
            · exact Fintype.one_lt_card;
            · rw [ tsub_add_tsub_cancel ( Nat.le_self_pow ( by linarith ) _ ) ( Nat.one_le_iff_ne_zero.mpr ( Fintype.card_ne_zero ) ) ];
          refine' ⟨ X, fun i x => x.val i, hX.1, _, _ ⟩ <;> simp_all +decide [ funext_iff ];
          -- By definition of $X$, for any $g : Fin n → X → F$, there exists a matrix $A \in M_{n, n+1}(\F)$ such that $g j x = \sum_{i=0}^{n} A j i * x i$ for all $x \in X$.
          intro g hg
          obtain ⟨A, hA⟩ : ∃ A : Matrix (Fin n) (Fin (n + 1)) F, ∀ j : Fin n, ∀ x : X, g j x = ∑ i : Fin (n + 1), A j i * x.val i := by
            have hA : ∀ j : Fin n, ∃ A : Fin (n + 1) → F, ∀ x : X, g j x = ∑ i : Fin (n + 1), A i * x.val i := by
              intro j; specialize hg j; rw [ Finsupp.mem_span_range_iff_exists_finsupp ] at hg; aesop;
              use w; intro a ha; replace h := congr_fun h ⟨ a, ha ⟩ ; simp_all +decide [ Finsupp.sum_fintype ] ;
            exact ⟨ fun j => Classical.choose ( hA j ), fun j x => Classical.choose_spec ( hA j ) x ⟩;
          -- By Lemma 2, there exists a non-zero vector $v \in \F^{n+1}$ such that $A v = 0$.
          obtain ⟨v, hv⟩ : ∃ v : Fin (n + 1) → F, v ≠ 0 ∧ A.mulVec v = 0 := by
            have h_rank : Matrix.rank A < n + 1 := by
              exact lt_of_le_of_lt ( Submodule.finrank_le _ ) ( by simp +decide );
            contrapose! h_rank;
            rw [ Matrix.rank ];
            rw [ @LinearMap.finrank_range_of_inj ];
            · simp +decide;
            · exact fun x y hxy => Classical.not_not.1 fun h => h_rank ( x - y ) ( sub_ne_zero_of_ne h ) ( by simpa [ sub_eq_add_neg, Matrix.mulVec_add, Matrix.mulVec_neg ] using sub_eq_zero.2 hxy );
          -- By definition of $X$, there exists $x \in X$ such that $v = c • x$ for some $c \in \F$.
          obtain ⟨x, hx⟩ : ∃ x : X, ∃ c : F, c ≠ 0 ∧ v = c • x.val := by
            obtain ⟨i, hi⟩ : ∃ i : Fin (n + 1), v i ≠ 0 := by
              exact Function.ne_iff.mp hv.1;
            obtain ⟨ x, hx, c, hc, hx' ⟩ := hX.2.2 v i hi;
            exact ⟨ ⟨ x, hx ⟩, c, hc, funext hx' ⟩;
          obtain ⟨ c, hc, rfl ⟩ := hx; simp_all +decide [ funext_iff, Matrix.mulVec, dotProduct ] ;
          simp_all +decide [ mul_left_comm, Finset.mul_sum _ _ _ ];
          exact ⟨ x, x.2, fun j => by simpa [ ← Finset.mul_sum _ _ _, hc ] using hv j ⟩

/-
Let $n > 0$ and let $\phi \colon \mathcal{F} \to \mathrm{Map}(\mathbb{A}^{n}(\F),\F)$ be a homomorphism of vector spaces over $\F$. Any subset of $\mathbb{A}^{n}(\F)$ defined by some members of $\mathcal{F}$ (i.e., the zero locus of their images via $\phi$) can be defined using at most $n$ members of $\mathcal{F}$.
-/
theorem corollary_2 (n : ℕ) (hn : n > 0) (V : Type*) [AddCommGroup V] [Module F V]
    (phi : V →ₗ[F] ((Fin n → F) → F)) (S : Set V) (hS : S.Finite) :
    ∃ T : Set V, T.Finite ∧ T.ncard ≤ n ∧ T ⊆ Submodule.span F S ∧ ZeroSet (phi '' T) = ZeroSet (phi '' S) := by
      -- Let $Y = \phi(S)$.
      set Y := phi '' S with hY;
      -- Apply Theorem 1 to the set Y.
      obtain ⟨T, hT⟩ : ∃ T : Set ((Fin n → F) → F), T ⊆ Submodule.span F Y ∧ T.Finite ∧ T.ncard ≤ n ∧ ZeroSet T = ZeroSet Y := by
        have h_base : ∀ (Y : Set ((Fin n → F) → F)), Y.Finite → Y.ncard > n → ∃ T : Set ((Fin n → F) → F), T ⊆ Submodule.span F Y ∧ T.Finite ∧ T.ncard ≤ n ∧ ZeroSet T = ZeroSet Y := by
          intro Y hY hY_card
          apply theorem_1 n Y hY hY_card;
          rcases k : Fintype.card F with ( _ | _ | k ) <;> simp_all +decide [ Nat.geomSum_eq ];
          · exact absurd k ( Nat.ne_of_gt ( Fintype.one_lt_card ) );
          · rw [ Nat.le_div_iff_mul_le ] <;> norm_num [ pow_succ' ];
            exact le_tsub_of_add_le_left ( by nlinarith [ pow_le_pow_right₀ ( by linarith : 1 ≤ Nat.succ ( Nat.succ ‹_› ) ) hn ] );
        by_cases hY_card : Y.ncard > n;
        · exact h_base Y ( hS.image _ ) hY_card;
        · refine' ⟨ Y, _, _, _, rfl ⟩;
          · exact Submodule.subset_span;
          · exact hS.image _;
          · exact le_of_not_gt hY_card;
      -- Since $T \subseteq \text{span}(Y)$ and $Y = \text{im}(\phi(S))$, we have $T \subseteq \text{im}(\text{span}(S))$.
      have hT_image : T ⊆ Set.image phi (Submodule.span F S) := by
        intro x hx;
        simp +zetaDelta at *;
        exact hT.1 hx;
      choose! f hf using hT_image;
      refine' ⟨ f '' T, _, _, _, _ ⟩;
      · exact hT.2.1.image _;
      · refine' le_trans ( Set.ncard_image_le _ ) hT.2.2.1;
        exact hT.2.1;
      · exact Set.image_subset_iff.2 fun x hx => hf hx |>.1;
      · simp_all +decide [ Set.ext_iff, ZeroSet ]

/-
The cardinality of the projective space minus a point is $\frac{q^{n+1}-q}{q-1}$.
-/
lemma card_projectivization_minus_point (n : ℕ) (α : Projectivization F (Fin (n + 1) → F)) :
    Nat.card {x : Projectivization F (Fin (n + 1) → F) // x ≠ α} =
    (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1) := by
      -- The cardinality of the projective space $\mathbb{P}^n(\mathbb{F})$ is $\frac{q^{n+1}-1}{q-1}$.
      have h_card_proj : Nat.card (Projectivization F (Fin (n + 1) → F)) = (Fintype.card F ^ (n + 1) - 1) / (Fintype.card F - 1) := by
        have := @Projectivization.card F;
        specialize this ( Fin ( n + 1 ) → F );
        rw [ Nat.div_eq_of_eq_mul_left ] <;> aesop;
        exact Fintype.one_lt_card;
      -- The cardinality of the set of all points in the projective space except α is the total cardinality minus 1.
      have h_card_set : Nat.card {x : Projectivization F (Fin (n + 1) → F) | x ≠ α} = Nat.card (Projectivization F (Fin (n + 1) → F)) - 1 := by
        haveI := Fintype.ofFinite ( Projectivization F ( Fin ( n + 1 ) → F ) ) ; rw [ Nat.card_eq_fintype_card, Nat.card_eq_fintype_card ] ; simp +decide [ Finset.filter_ne' ] ;
      -- Substitute h_card_proj into h_card_set to get the desired result.
      rw [h_card_proj] at h_card_set;
      norm_num +zetaDelta at *;
      rw [ h_card_set, Nat.sub_eq_of_eq_add ];
      rw [ show Fintype.card F ^ ( n + 1 ) - 1 = ( Fintype.card F ^ ( n + 1 ) - Fintype.card F ) + ( Fintype.card F - 1 ) from ?_, Nat.add_div ];
      · rcases k : Fintype.card F with ( _ | _ | k ) <;> simp_all +decide [ Nat.mod_eq_of_lt ];
        exact Nat.mod_lt _ ( Nat.succ_pos _ );
      · exact Nat.sub_pos_of_lt ( Fintype.one_lt_card );
      · rw [ tsub_add_tsub_cancel ( Nat.le_self_pow ( by norm_num ) _ ) ( Nat.one_le_iff_ne_zero.mpr ( Fintype.card_ne_zero ) ) ]

/-
Let $n \ge 0$ and let
	$\phi \colon \mathcal{F} \to \mathrm{Map}(\mathbb{P}^{n}(\F),\F)$ be a homomorphism of vector spaces over $\F$. Any nonempty subset of $\mathbb{P}^{n}(\F)$ defined by some members of $\mathcal{F}$ (i.e., the zero locus of their images via $\phi$) can be defined using at most $n$ members of $\mathcal{F}$.
-/
theorem corollary_3 (n : ℕ) (V : Type*) [AddCommGroup V] [Module F V]
    (phi : V →ₗ[F] (Projectivization F (Fin (n + 1) → F) → F)) (S : Set V) (hS : S.Finite)
    (h_nonempty : ZeroSet (phi '' S) ≠ ∅) :
    ∃ T : Set V, T.Finite ∧ T.ncard ≤ n ∧ T ⊆ Submodule.span F S ∧ ZeroSet (phi '' T) = ZeroSet (phi '' S) := by
      obtain ⟨ α, hα ⟩ := Set.nonempty_iff_ne_empty.2 h_nonempty;
      -- Let $X' = \mathbb{P}^n(\mathbb{F}) \setminus \{\alpha\}$.
      set X' := {x : Projectivization F (Fin (n + 1) → F) | x ≠ α};
      -- By `theorem_1`, there exists a set $T' \subseteq \text{span}(Y')$ with $|T'| \le n$ such that $\text{ZeroSet}(T') = \text{ZeroSet}(Y')$.
      obtain ⟨T', hT'_finite, hT'_card, hT'_span, hT'_zero⟩ : ∃ T' : Set (X' → F), T'.Finite ∧ T'.ncard ≤ n ∧ T' ⊆ Submodule.span F (Set.image (fun f => fun x : X' => f x) (phi '' S)) ∧ ZeroSet T' = ZeroSet (Set.image (fun f => fun x : X' => f x) (phi '' S)) := by
        have h_card_X' : Nat.card X' = (Fintype.card F ^ (n + 1) - Fintype.card F) / (Fintype.card F - 1) := by
          convert card_projectivization_minus_point n α using 1;
        have := theorem_1 n ( Set.image ( fun f => fun x : X' => f x ) ( phi '' S ) );
        by_cases h : Set.ncard ( Set.image ( fun f => fun x : X' => f x ) ( phi '' S ) ) > n <;> simp_all +decide;
        · exact Exists.imp ( by aesop ) ( this ( Set.Finite.image _ ( Set.Finite.image _ hS ) ) );
        · refine' ⟨ _, _, h, _, rfl ⟩;
          · exact Set.Finite.image _ ( Set.Finite.image _ hS );
          · exact fun x hx => Submodule.subset_span hx;
      -- Since $T' \subseteq \text{span}(res(Y)) = res(\text{span}(Y))$, we can lift $T'$ to $T_{span} \subseteq \text{span}(Y)$ such that $res(T_{span}) = T'$.
      obtain ⟨T_span, hT_span⟩ : ∃ T_span : Set (Projectivization F (Fin (n + 1) → F) → F), T_span.Finite ∧ T_span.ncard ≤ n ∧ T_span ⊆ Submodule.span F (phi '' S) ∧ Set.image (fun f => fun x : X' => f x) T_span = T' := by
        have h_lift : ∀ f ∈ T', ∃ g ∈ Submodule.span F (phi '' S), (fun x : X' => g x) = f := by
          intro f hf
          have h_lift : f ∈ Submodule.span F (Set.image (fun f => fun x : X' => f x) (phi '' S)) := by
            exact hT'_span hf;
          rw [ Finsupp.mem_span_image_iff_linearCombination ] at h_lift;
          obtain ⟨ l, hl₁, hl₂ ⟩ := h_lift;
          refine' ⟨ ∑ i ∈ l.support, l i • i, _, _ ⟩;
          · exact Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ( Submodule.subset_span ( hl₁ hi ) );
          · simp +decide [ ← hl₂, Finsupp.linearCombination_apply ];
            simp +decide [ Finsupp.sum, funext_iff ];
        choose! g hg₁ hg₂ using h_lift;
        refine' ⟨ Set.image g T', _, _, _, _ ⟩;
        · exact hT'_finite.image _;
        · rw [ Set.ncard_image_of_injOn ];
          · exact hT'_card;
          · intro f hf f' hf' hgf; have := hg₂ f hf; have := hg₂ f' hf'; aesop;
        · exact Set.image_subset_iff.mpr hg₁;
        · ext f; aesop;
      -- Since elements of $T_{span}$ are in $\text{span}(Y)$ and elements of $Y$ vanish at $\alpha$, elements of $T_{span}$ vanish at $\alpha$.
      have hT_span_zero : ∀ f ∈ T_span, f α = 0 := by
        intro f hf;
        have hT_span_zero : ∀ f ∈ Submodule.span F (phi '' S), f α = 0 := by
          intro f hf;
          rw [ Finsupp.mem_span_image_iff_linearCombination ] at hf;
          rcases hf with ⟨ l, hl, rfl ⟩;
          simp_all +decide [ Finsupp.linearCombination_apply, Finsupp.sum ];
          exact Finset.sum_eq_zero fun x hx => mul_eq_zero_of_right _ ( hα _ ⟨ x, hl hx, rfl ⟩ );
        exact hT_span_zero f ( hT_span.2.2.1 hf );
      -- Thus $\text{ZeroSet}(T_{span}) = \{\alpha\} \cup \text{ZeroSet}(T') = \{\alpha\} \cup \text{ZeroSet}(Y') = \text{ZeroSet}(Y)$.
      have hT_span_zero_set : ZeroSet T_span = ZeroSet (phi '' S) := by
        ext x;
        by_cases hx : x = α <;> simp_all +decide [ Set.ext_iff ];
        · exact fun f hf => hT_span_zero f hf;
        · simp_all +decide [ ZeroSet ];
          convert hT'_zero x hx using 1;
          constructor <;> intro h f hf;
          · obtain ⟨ g, hg, rfl ⟩ := hT_span.2.2.2 f |>.2 hf; exact h _ hg;
          · specialize hT_span ; replace hT_span := hT_span.2.2.2 ( fun y => f y ) ; aesop;
            specialize hT'_zero x hx ; aesop;
            exact hT'_zero _ ( hT_span.mp ⟨ f, hf, rfl ⟩ );
      -- Finally, lift $T_{span}$ back to $S$ via $\phi$. Since $T_{span} \subseteq \text{span}(\phi(S))$, we can find preimages in $\text{span}(S)$.
      obtain ⟨T, hT⟩ : ∃ T : Set V, T.Finite ∧ T.ncard ≤ n ∧ T ⊆ Submodule.span F S ∧ Set.image phi T = T_span := by
        have hT_span_preimage : ∀ f ∈ T_span, ∃ g ∈ Submodule.span F S, phi g = f := by
          intro f hf;
          simp +zetaDelta at *;
          exact hT_span.2.2.1 hf;
        choose! g hg using hT_span_preimage;
        refine' ⟨ Set.image g T_span, _, _, _, _ ⟩;
        · exact hT_span.1.image _;
        · rw [ Set.ncard_image_of_injOn ];
          · exact hT_span.2.1;
          · intro f hf f' hf' hgf; have := hg f hf; have := hg f' hf'; aesop;
        · exact Set.image_subset_iff.mpr fun f hf => hg f hf |>.1;
        · grind;
      aesop

#check corollary_3

/-
Consider the system of $n$ polynomials $f_{i}(x_{1}, \ldots, x_{n})=x_{i}$. While $\mathrm{Z}(f_{1}, \ldots, f_{k})=\left\lbrace \theta\right\rbrace$, any system of $n-1$ combinations of them has at least $q$ common zeros.
-/
theorem remark_example (n : ℕ) (hn : n > 0) :
    let f : Fin n → (Fin n → F) → F := fun i x => x i
    ZeroSet (Set.range f) = {0} ∧
    ∀ (g : Fin (n - 1) → (Fin n → F) → F),
      (∀ j, g j ∈ Submodule.span F (Set.range f)) →
      (ZeroSet (Set.range g)).ncard ≥ Fintype.card F := by
        -- Let's unfold the definition of zero set.
        unfold ZeroSet;
        cases n <;> aesop;
        · aesop;
        · -- Since $g_j$ are linear combinations of the coordinate functions $f_i$, the zero set of the $g_j$ is the set of vectors $x$ such that $Mx = 0$, where $M$ is the matrix whose rows are the coefficients of the $g_j$.
          obtain ⟨M, hM⟩ : ∃ M : Matrix (Fin n) (Fin (n + 1)) F, ∀ x, (∀ j, g j x = 0) ↔ M.mulVec x = 0 := by
            choose M hM using fun j => Submodule.mem_span_range_iff_exists_fun F |>.1 ( a j );
            use Matrix.of M;
            simp +decide [ ← hM, funext_iff, Matrix.mulVec, dotProduct ];
          -- Since $M$ is an $n \times (n + 1)$ matrix, the kernel of $M$ has dimension at least 1.
          have h_kernel_dim : 1 ≤ Module.finrank F (LinearMap.ker (Matrix.mulVecLin M)) := by
            have := LinearMap.finrank_range_add_finrank_ker ( Matrix.mulVecLin M ) ; aesop;
            rw [ a_1, finrank_bot ] at this ; linarith [ show Module.finrank F ( LinearMap.range M.mulVecLin ) ≤ n by exact le_trans ( Submodule.finrank_le _ ) ( by simp +decide ) ];
          -- Since the kernel of $M$ has dimension at least 1, it contains at least $q$ elements.
          have h_kernel_card : Fintype.card F ≤ Nat.card (LinearMap.ker (Matrix.mulVecLin M)) := by
            have h_kernel_card : Fintype.card F ≤ Fintype.card (LinearMap.ker (Matrix.mulVecLin M)) := by
              have h_kernel_card : Fintype.card (LinearMap.ker (Matrix.mulVecLin M)) = Fintype.card F ^ Module.finrank F (LinearMap.ker (Matrix.mulVecLin M)) := by
                exact?;
              exact h_kernel_card.symm ▸ Nat.le_self_pow ( by positivity ) _;
            aesop;
          simp_all +decide [ Set.ncard_eq_toFinset_card' ];
          simpa [ Fintype.card_subtype ] using h_kernel_card
